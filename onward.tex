%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen]{acmart}

\usepackage{code}
\usepackage{graphicx}
\usepackage{placeins}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%% The following is specific to Onward! '24-ESSAYS and the paper
%%% '(Programs), Proofs and Refutations (and Tests and Mutants)'
%%% by Alex Groce.
%%%
\setcopyright{acmlicensed}
\acmDOI{10.1145/3689492.3689810}
\acmYear{2024}
\copyrightyear{2024}
\acmISBN{979-8-4007-1215-9/24/10}
\acmConference[Onward! '24]{Proceedings of the 2024 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software}{October 23--25, 2024}{Pasadena, CA, USA}
\acmBooktitle{Proceedings of the 2024 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward! '24), October 23--25, 2024, Pasadena, CA, USA}
\acmSubmissionID{onward24essays-p7-p}
\received{2024-04-25}
\received[accepted]{2024-08-08}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Mutation Driven Development}

\author{Alex Groce}
\orcid{0000-0003-0273-4668}
\affiliation{%
  \institution{Northern Arizona University}
  \city{Flagstaff}
  \country{USA}
}
\email{agroce@gmail.com}

%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Alex Groce}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}

\end{abstract}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10010940.10010992.10010998.10011001</concept_id>
<concept_desc>Software and its engineering~Dynamic analysis</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011074.10011099.10011102.10011103</concept_id>
<concept_desc>Software and its engineering~Software testing and debugging</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Dynamic analysis}
\ccsdesc[500]{Software and its engineering~Software testing and debugging}

\keywords{software testing software verification, proof, counterexample, tests}



\begin{abstract}
Test driven development (TDD) is a controversial and interesting approach to
software development; while many think of ``better tests'' as a
primary \emph{purpose} of TDD, in practice the goal is as much to use
tests to encourage continued progress in coding.   That goal however
rests on the notion that TDD ensures tests are good enough to let you
implement small new features and refactor code without undue fear of
mistakes.  Unfortunately, TDD is not ``self-enforcing'' and standard
TDD practice makes it easy to accidentally skip steps.  By integrating
a phase of focused mutation testing into TDD, however, developers
applying TDD can be sure they are not writing code that is not
supported by the scaffolding of tests.  The incremental nature of TDD
test and production code creation ensures that at no point will
``fixing up'' the mutants be likely to overwhelm the developer, and so
the final result will be tests with excellent code coverage and
mutation score, without a painful effort to ``patch up'' an inadequate
testing effort, and a TDD approach that includes automated checks that
the letter and spirit of TDD are truly being respected, and the
benefits of TDD presumably following in due course.
  \end{abstract}



\maketitle


\section{Introduction}

The first question I should answer: given the abstract, which sounds
like a fairly standard software engineering research paper abstract,
except for the missing part bragging
about a positive experimental evaluation, why is this an Onward! Essay
and not a conventional research paper?

The answer is personal:  I thought of this idea a few years ago, and
have thought about making it a full research project off and on since
then, and I
never managed to actually do so.  A real evaluation of this idea would
require a good graduate student's devotion, and, more importantly,
actual human-subjects experimentation work to arrive at even a
speculative and provisional scientific evaluation of the idea's
efficacy.  I can't think of a useful way to make a purely ``extract
code from public repos and analyze it'' investigation, or (better yet)
a purely mechanical experiment.  Perhaps in a few years it will be
possible to just have LLMs do it all?

I (read: ``my lab'') don't really do human subjects; I don't ever want do
write IRB paperwork.  I do work with people who do human subjects,
from time to time; so I could potentially convince one of those
wonderful folks that this is a good project, and thus avoid doing IRB
paperwork and still make this a ``real'' paper.

But I don't have a huge committment to Test
Driven Development to get me excited enough to try to talk someone
else into spending valuable research productivity time on this idea; I've never used
TDD in writing code myself, and I'm not sure if I think it's a good development
practice.  Nobody I know and trust in the real software industry seems
to do things in a TDD way, which is suggestive.  So it just doesn't
seem worth it to commit to a serious Research Project, likely spanning
over a year, to this idea.

So why not do what we senior researchers usually do in this situation?
Shelve the idea, perhaps mention it to one or two people, and let it
basically die?  I've done this before; there are a good half-dozen
implmentations of test generation ideas I think might be interesting
or effective in my TSTL Python test generation tool, none of which
ever became a paper.  They live only as obscure command line options
to a tool increasingly few people are likely to ever use.  It's sad,
but life is short, and I don't think any of those ideas are likely to
be \emph{really} important, vs. somewhat, occasionally, useful.

\subsubsection{Daniel Jackson Made Me Do It}

I recently read Daniel Jackson's \emph{The Essence of Software}, which
is a very enjoyable book.  The supposed topic of the book is an
approach to design that I thought was interesting, but that also seems
more appropriate to UI-heavy software for ``normal people'' than the
kind of code analysis/test generation software I tend to write
myself.  The real value of the book was, for me, twofold:  first, the
long long set of ``notes'' after the main text is a delightful random
walk through software engineering.  Second, Jackson's musings include
a major theme:  we've become too careful in the software engineering
research community.  Given the heroic (for lazy computer scientists,
at least;
obviously almost every research project in SE is a joke compared to
the work of serious systems people, much less biologists or
physicists) effort required for making Real Science that Has Six Good
RQs and Makes it Past the ICSE Program Committee,   There was a time
when SE (or formal methods, where I was living at that time) was far
too accepting of a paper based on application of an approach to a
single toy problem, plus a good writeup.  This was too lacking in
rigor, and there was a very sensible effort to increase the level of
experimental support for claims about software engineering.  I don't
have a strong opinion on how this worked out for more methdological
aspects of SE, but for the most part increased rigor was necessary to
make work in more ``technical'' parts of SE, such as software testing,
trustworthy.

\subsection{What is Test Driven Development?}

Test Driven Development (henceforth TDD) has been defined many times,
in many ways.  Even if you're familliar with TDD, I would like to
revisit the foundations for a moment, because the proposal made here
is formulated with respect to a particular conception of TDD.  Most
definitions of TDD (including this one) properly present it as a
\emph{series of steps to be followed in development}.

\begin{enumerate}
  \item Think of a behavior your software does not yet have,
    but that you want it to have.
    \item Add a test that would pass if that behavior was present, but
      will not pass if it is not.
    \item Run all your tests and see that the newly added test fails.
    \item Make a \emph{small} change that makes the test pass.
    \item Run all the tests; make sure they all succeed now.
      \item Refactor to remove duplication/generally clean the code
        from step 4 up so it doesn't make you ashamed of yourself.
      \end{enumerate}

I added the first step, because you can't really write a test until
you've thought of something to test.

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}



\end{document}